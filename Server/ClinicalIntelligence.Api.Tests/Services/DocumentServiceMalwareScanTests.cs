using System.Text;
using ClinicalIntelligence.Api.Contracts;
using ClinicalIntelligence.Api.Data;
using ClinicalIntelligence.Api.Services;
using ClinicalIntelligence.Api.Services.Security;
using ClinicalIntelligence.Api.Tests.Helpers;
using Microsoft.AspNetCore.Http;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Moq;
using Xunit;

namespace ClinicalIntelligence.Api.Tests.Services;

/// <summary>
/// Tests for DocumentService malware scanning integration (US_048).
/// Verifies malware detection, quarantine, and audit logging behavior.
/// </summary>
public class DocumentServiceMalwareScanTests : IDisposable
{
    private readonly ApplicationDbContext _dbContext;
    private readonly Mock<ILogger<DocumentService>> _loggerMock;
    private readonly Mock<IDocumentIntegrityValidator> _integrityValidatorMock;
    private readonly Mock<IAuditLogWriter> _auditLogWriterMock;

    public DocumentServiceMalwareScanTests()
    {
        var options = new DbContextOptionsBuilder<ApplicationDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        _dbContext = new ApplicationDbContext(options);
        _loggerMock = new Mock<ILogger<DocumentService>>();
        _integrityValidatorMock = new Mock<IDocumentIntegrityValidator>();
        _auditLogWriterMock = new Mock<IAuditLogWriter>();

        // Default integrity validator returns valid
        _integrityValidatorMock
            .Setup(v => v.ValidateAsync(It.IsAny<Stream>(), It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new DocumentValidationResult { IsValid = true });
    }

    public void Dispose()
    {
        _dbContext.Dispose();
    }

    private static IFormFile CreateMockFile(string fileName, byte[] content, string contentType)
    {
        var stream = new MemoryStream(content);
        var fileMock = new Mock<IFormFile>();
        fileMock.Setup(f => f.FileName).Returns(fileName);
        fileMock.Setup(f => f.Length).Returns(content.Length);
        fileMock.Setup(f => f.ContentType).Returns(contentType);
        fileMock.Setup(f => f.OpenReadStream()).Returns(() => new MemoryStream(content));
        return fileMock.Object;
    }

    private static byte[] CreateValidPdfContent()
    {
        var pdfContent = @"%PDF-1.4
1 0 obj<</Type/Catalog/Pages 2 0 R>>endobj
2 0 obj<</Type/Pages/Count 0/Kids[]>>endobj
xref
0 3
trailer<</Size 3/Root 1 0 R>>
startxref
97
%%EOF";
        return Encoding.ASCII.GetBytes(pdfContent);
    }

    #region Clean File Tests

    [Fact]
    public async Task ValidateAndAcknowledge_CleanFile_ReturnsIsValidTrue()
    {
        // Arrange
        var scannerMock = MalwareTestHelpers.CreateMockCleanScanner();
        var service = new DocumentService(
            _dbContext, 
            _loggerMock.Object, 
            _integrityValidatorMock.Object,
            scannerMock.Object,
            _auditLogWriterMock.Object);

        var content = CreateValidPdfContent();
        var file = CreateMockFile("clean.pdf", content, "application/pdf");

        // Act
        var result = await service.ValidateAndAcknowledgeAsync(file, Guid.NewGuid(), Guid.NewGuid());

        // Assert
        Assert.True(result.IsValid);
        Assert.Null(result.ErrorCode);
        Assert.Equal("Accepted", result.Status);
    }

    [Fact]
    public async Task ValidateAndAcknowledge_CleanFile_CallsScanner()
    {
        // Arrange
        var scannerMock = MalwareTestHelpers.CreateMockCleanScanner();
        var service = new DocumentService(
            _dbContext, 
            _loggerMock.Object, 
            _integrityValidatorMock.Object,
            scannerMock.Object,
            _auditLogWriterMock.Object);

        var content = CreateValidPdfContent();
        var file = CreateMockFile("test.pdf", content, "application/pdf");

        // Act
        await service.ValidateAndAcknowledgeAsync(file, Guid.NewGuid(), Guid.NewGuid());

        // Assert
        scannerMock.Verify(s => s.ScanAsync(It.IsAny<Stream>(), "test.pdf", It.IsAny<CancellationToken>()), Times.Once);
    }

    #endregion

    #region Infected File Tests

    [Fact]
    public async Task ValidateAndAcknowledge_InfectedFile_ReturnsIsValidFalse()
    {
        // Arrange
        var scannerMock = MalwareTestHelpers.CreateMockInfectedScanner("Trojan.Test", "Trojan");
        var service = new DocumentService(
            _dbContext, 
            _loggerMock.Object, 
            _integrityValidatorMock.Object,
            scannerMock.Object,
            _auditLogWriterMock.Object);

        var content = MalwareTestHelpers.CreateEicarTestFile();
        var file = CreateMockFile("infected.pdf", content, "application/pdf");

        // Act
        var result = await service.ValidateAndAcknowledgeAsync(file, Guid.NewGuid(), Guid.NewGuid());

        // Assert
        Assert.False(result.IsValid);
        Assert.Equal("ValidationFailed", result.Status);
    }

    [Fact]
    public async Task ValidateAndAcknowledge_InfectedFile_ReturnsMalwareDetectedError()
    {
        // Arrange
        var scannerMock = MalwareTestHelpers.CreateMockInfectedScanner("Trojan.Test", "Trojan");
        var service = new DocumentService(
            _dbContext, 
            _loggerMock.Object, 
            _integrityValidatorMock.Object,
            scannerMock.Object,
            _auditLogWriterMock.Object);

        var content = MalwareTestHelpers.CreateEicarTestFile();
        var file = CreateMockFile("infected.pdf", content, "application/pdf");

        // Act
        var result = await service.ValidateAndAcknowledgeAsync(file, Guid.NewGuid(), Guid.NewGuid());

        // Assert
        Assert.Equal(FileValidationErrorCode.MalwareDetected, result.ErrorCode);
        Assert.Equal("malware_detected", result.ErrorType);
        Assert.Contains(result.ValidationErrors, e => e.Contains("Security threat detected"));
    }

    [Fact]
    public async Task ValidateAndAcknowledge_InfectedFile_IncludesThreatNameInError()
    {
        // Arrange
        var scannerMock = MalwareTestHelpers.CreateMockInfectedScanner("Eicar-Test-Signature", "Test");
        var service = new DocumentService(
            _dbContext, 
            _loggerMock.Object, 
            _integrityValidatorMock.Object,
            scannerMock.Object,
            _auditLogWriterMock.Object);

        var content = MalwareTestHelpers.CreateEicarTestFile();
        var file = CreateMockFile("eicar.pdf", content, "application/pdf");

        // Act
        var result = await service.ValidateAndAcknowledgeAsync(file, Guid.NewGuid(), Guid.NewGuid());

        // Assert
        Assert.Contains(result.ValidationErrors, e => e.Contains("Eicar-Test-Signature"));
    }

    [Fact]
    public async Task ValidateAndAcknowledge_InfectedFile_LogsAuditEvent()
    {
        // Arrange
        var scannerMock = MalwareTestHelpers.CreateMockInfectedScanner("Trojan.Test", "Trojan");
        _auditLogWriterMock
            .Setup(a => a.WriteAsync(
                It.IsAny<string>(),
                It.IsAny<Guid?>(),
                It.IsAny<Guid?>(),
                It.IsAny<string?>(),
                It.IsAny<Guid?>(),
                It.IsAny<string?>(),
                It.IsAny<string?>(),
                It.IsAny<object?>(),
                It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);

        var service = new DocumentService(
            _dbContext, 
            _loggerMock.Object, 
            _integrityValidatorMock.Object,
            scannerMock.Object,
            _auditLogWriterMock.Object);

        var content = MalwareTestHelpers.CreateEicarTestFile();
        var file = CreateMockFile("infected.pdf", content, "application/pdf");
        var userId = Guid.NewGuid();

        // Act
        await service.ValidateAndAcknowledgeAsync(file, Guid.NewGuid(), userId);

        // Assert
        _auditLogWriterMock.Verify(a => a.WriteAsync(
            "MALWARE_DETECTED",
            userId,
            It.IsAny<Guid?>(),
            "Document",
            It.IsAny<Guid?>(),
            It.IsAny<string?>(),
            It.IsAny<string?>(),
            It.IsAny<object?>(),
            It.IsAny<CancellationToken>()), Times.Once);
    }

    #endregion

    #region Scanner Unavailable Tests

    [Fact]
    public async Task ValidateAndAcknowledge_ScannerUnavailable_ContinuesWithoutBlocking()
    {
        // Arrange
        var scannerMock = MalwareTestHelpers.CreateMockUnavailableScanner();
        var service = new DocumentService(
            _dbContext, 
            _loggerMock.Object, 
            _integrityValidatorMock.Object,
            scannerMock.Object,
            _auditLogWriterMock.Object);

        var content = CreateValidPdfContent();
        var file = CreateMockFile("test.pdf", content, "application/pdf");

        // Act
        var result = await service.ValidateAndAcknowledgeAsync(file, Guid.NewGuid(), Guid.NewGuid());

        // Assert - Should still be valid since scanner is unavailable (not blocking)
        Assert.True(result.IsValid);
    }

    [Fact]
    public async Task ValidateAndAcknowledge_NoScanner_ReturnsValidForCleanFile()
    {
        // Arrange - No malware scanner injected
        var service = new DocumentService(
            _dbContext, 
            _loggerMock.Object, 
            _integrityValidatorMock.Object,
            null, // No scanner
            _auditLogWriterMock.Object);

        var content = CreateValidPdfContent();
        var file = CreateMockFile("test.pdf", content, "application/pdf");

        // Act
        var result = await service.ValidateAndAcknowledgeAsync(file, Guid.NewGuid(), Guid.NewGuid());

        // Assert
        Assert.True(result.IsValid);
    }

    #endregion

    #region Scan Timeout Tests

    [Fact]
    public async Task ValidateAndAcknowledge_ScanTimeout_ReturnsScanTimeoutError()
    {
        // Arrange
        var scannerMock = MalwareTestHelpers.CreateMockTimeoutScanner();
        var service = new DocumentService(
            _dbContext, 
            _loggerMock.Object, 
            _integrityValidatorMock.Object,
            scannerMock.Object,
            _auditLogWriterMock.Object);

        var content = CreateValidPdfContent();
        var file = CreateMockFile("test.pdf", content, "application/pdf");

        // Act
        var result = await service.ValidateAndAcknowledgeAsync(file, Guid.NewGuid(), Guid.NewGuid());

        // Assert
        Assert.False(result.IsValid);
        Assert.Equal(FileValidationErrorCode.ScanTimeout, result.ErrorCode);
        Assert.Equal("scan_timeout", result.ErrorType);
        Assert.Contains(result.ValidationErrors, e => e.Contains("timed out"));
    }

    #endregion

    #region Scan Error Tests

    [Fact]
    public async Task ValidateAndAcknowledge_ScanError_ContinuesWithoutBlocking()
    {
        // Arrange
        var scannerMock = MalwareTestHelpers.CreateMockErrorScanner("Connection refused");
        var service = new DocumentService(
            _dbContext, 
            _loggerMock.Object, 
            _integrityValidatorMock.Object,
            scannerMock.Object,
            _auditLogWriterMock.Object);

        var content = CreateValidPdfContent();
        var file = CreateMockFile("test.pdf", content, "application/pdf");

        // Act
        var result = await service.ValidateAndAcknowledgeAsync(file, Guid.NewGuid(), Guid.NewGuid());

        // Assert - Should still be valid since scan error doesn't block
        Assert.True(result.IsValid);
    }

    #endregion

    #region Validation Order Tests

    [Fact]
    public async Task ValidateAndAcknowledge_InvalidExtension_SkipsMalwareScan()
    {
        // Arrange
        var scannerMock = MalwareTestHelpers.CreateMockCleanScanner();
        var service = new DocumentService(
            _dbContext, 
            _loggerMock.Object, 
            _integrityValidatorMock.Object,
            scannerMock.Object,
            _auditLogWriterMock.Object);

        var content = Encoding.UTF8.GetBytes("test content");
        var file = CreateMockFile("test.txt", content, "text/plain");

        // Act
        var result = await service.ValidateAndAcknowledgeAsync(file, Guid.NewGuid(), Guid.NewGuid());

        // Assert
        Assert.False(result.IsValid);
        Assert.Equal(FileValidationErrorCode.InvalidExtension, result.ErrorCode);
        // Scanner should not be called for invalid extension
        scannerMock.Verify(s => s.ScanAsync(It.IsAny<Stream>(), It.IsAny<string>(), It.IsAny<CancellationToken>()), Times.Never);
    }

    [Fact]
    public async Task ValidateAndAcknowledge_EmptyFile_SkipsMalwareScan()
    {
        // Arrange
        var scannerMock = MalwareTestHelpers.CreateMockCleanScanner();
        var service = new DocumentService(
            _dbContext, 
            _loggerMock.Object, 
            _integrityValidatorMock.Object,
            scannerMock.Object,
            _auditLogWriterMock.Object);

        var file = CreateMockFile("empty.pdf", Array.Empty<byte>(), "application/pdf");

        // Act
        var result = await service.ValidateAndAcknowledgeAsync(file, Guid.NewGuid(), Guid.NewGuid());

        // Assert
        Assert.False(result.IsValid);
        Assert.Equal(FileValidationErrorCode.FileEmpty, result.ErrorCode);
        scannerMock.Verify(s => s.ScanAsync(It.IsAny<Stream>(), It.IsAny<string>(), It.IsAny<CancellationToken>()), Times.Never);
    }

    #endregion
}
